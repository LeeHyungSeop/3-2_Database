<?xml version="1.0" encoding="UTF-8"?><sqlb_project><db path="/Users/ihyeongseob/Desktop/인천대/3학년/2학기/데이터베이스/SQL_실습/admission.db" readonly="0" foreign_keys="1" case_sensitive_like="0" temp_store="0" wal_autocheckpoint="1000" synchronous="2"/><attached/><window><main_tabs open="structure browser pragmas query" current="3"/></window><tab_structure><column_width id="0" width="300"/><column_width id="1" width="0"/><column_width id="2" width="100"/><column_width id="3" width="2246"/><column_width id="4" width="0"/><expanded_item id="0" parent="1"/><expanded_item id="1" parent="1"/><expanded_item id="2" parent="1"/><expanded_item id="3" parent="1"/></tab_structure><tab_browse><current_table name="4,5:mainApply"/><default_encoding codec=""/><browse_table_settings><table schema="main" name="Apply" show_row_id="0" encoding="" plot_x_axis="" unlock_view_pk="_rowid_"><sort/><column_widths><column index="1" value="31"/><column index="2" value="53"/><column index="3" value="83"/><column index="4" value="52"/></column_widths><filter_values/><conditional_formats/><row_id_formats/><display_formats/><hidden_columns/><plot_y_axes/><global_filter/></table><table schema="main" name="College" show_row_id="0" encoding="" plot_x_axis="" unlock_view_pk="_rowid_"><sort/><column_widths><column index="1" value="53"/><column index="2" value="35"/><column index="3" value="64"/></column_widths><filter_values/><conditional_formats/><row_id_formats/><display_formats/><hidden_columns/><plot_y_axes/><global_filter/></table><table schema="main" name="Student" show_row_id="0" encoding="" plot_x_axis="" unlock_view_pk="_rowid_"><sort/><column_widths><column index="1" value="31"/><column index="2" value="47"/><column index="3" value="30"/><column index="4" value="44"/></column_widths><filter_values/><conditional_formats/><row_id_formats/><display_formats/><hidden_columns/><plot_y_axes/><global_filter/></table></browse_table_settings></tab_browse><tab_sql><sql name="SQL 3">-- 참조 당하는 table을 먼저 만드는 것이 좋다 
-- SQL은 대, 소문자 구별을 안 한다.  (College == college)
-- 그런데 &quot;(string)&quot; 에 들어갈 때는 대, 소문자 구별이 된다.

drop table if exists Apply;
drop table if exists Student;
drop table if exists College;

create table College(
	cName text, 	state text, 	enrollment int,
	
	primary key (cName)
);

create table Student(
	sID int, 	sName text, 	GPA real, 	sizeHS int,
	
	CONSTRAINT STUPK -- 이런 식으로 constraint에 이름을 부여할 수 있음
		primary key(sID),
	CONSTRAINT STUGPACHECK -- 이런 식으로 constraint에 이름을 부여할 수 있음
		CHECK (GPA &gt;= 0.0 and GPA &lt;= 4.5) -- expr 추가 
);

create table Apply(
	sID int, 	
	cName text NOT NULL DEFAULT &quot;INU&quot;, 
	major text, 
	decision text,
	
	primary key(sID, cName, major),
	-- 만약 Student Table의 sID가 삭제, 변경된다면? Apply table의 sID도 삭제, 변경
	foreign key (sID) references Student(sID) on delete cascade on update cascade,
	-- 만약 College Table의 cNAME가 삭제된다면? Apply Table의 cNAME는 DEFAULT값으로 변경.
	foreign key (cName) references College(cName) ON DELETE SET DEFAULT on update cascade
);

</sql><sql name="SQL 4">-- &quot;Bulk data&quot; load

delete from Student;
delete from College;
delete from Apply;

insert into Student values (123, 'Amy', 3.9, 1000);
insert into Student values (234, 'Bob', 3.6, 1500);
insert into Student values (345, 'Craig', 3.5, 500);
insert into Student values (456, 'Doris', 3.9, 1000);
insert into Student values (567, 'Edward', 2.9, 2000);
insert into Student values (678, 'Fay', 3.8, 200);
insert into Student values (789, 'Gary', 3.4, 800);
insert into Student values (987, 'Helen', 3.7, 800);
insert into Student values (876, 'Irene', 3.9, 400);
insert into Student values (765, 'Jay', 2.9, 1500);
insert into Student values (654, 'Amy', 3.9, 1000);
insert into Student values (543, 'Craig', 3.4, 2000);

insert into College values ('Stanford', 'CA', 15000);
insert into College values ('Berkeley', 'CA', 36000);
insert into College values ('MIT', 'MA', 10000);
insert into College values ('Cornell', 'NY', 21000);

insert into Apply values (123, 'Stanford', 'CS', 'Y');
insert into Apply values (123, 'Stanford', 'EE', 'N');
insert into Apply values (123, 'Berkeley', 'CS', 'Y');
insert into Apply values (123, 'Cornell', 'EE', 'Y');
insert into Apply values (234, 'Berkeley', 'biology', 'N');
insert into Apply values (345, 'MIT', 'bioengineering', 'Y');
insert into Apply values (345, 'Cornell', 'bioengineering', 'N');
insert into Apply values (345, 'Cornell', 'CS', 'Y');
insert into Apply values (345, 'Cornell', 'EE', 'N');
insert into Apply values (678, 'Stanford', 'history', 'Y');
insert into Apply values (987, 'Stanford', 'CS', 'Y');
insert into Apply values (987, 'Berkeley', 'CS', 'Y');
insert into Apply values (876, 'Stanford', 'CS', 'N');
insert into Apply values (876, 'MIT', 'biology', 'Y');
insert into Apply values (876, 'MIT', 'marine biology', 'N');
insert into Apply values (765, 'Stanford', 'history', 'Y');
insert into Apply values (765, 'Cornell', 'history', 'N');
insert into Apply values (765, 'Cornell', 'psychology', 'Y');
insert into Apply values (543, 'MIT', 'CS', 'N');
</sql><sql name="SQL 5">-- INSERT into Student value (111, 'hyungseop', 4.9, 1000); -- GPA를 4.9로 한다면? error... 이전에 우리가
																												-- check (GPA &gt;= 0.0 and GPA &lt;= 4.5) 로 check constraint를 추가했기 때문에
																												
UPDATE Student set sid=100 where sid=123; -- Student table의 sid가 123인 애들의 siD를 100으로 바꿔라																												</sql><sql name="SQL 6">-- 10주차 수요일 수업시간

-- select, from, where 실습

-- 1. GPA가 3.6보다 큰 학생의 아이디, 이름, GPA를 구하시오
-- SELECT sID, sName, GPA
-- FROM  Student
-- WHERE GPA &gt; 3.6;

-- 2. GPA가 3.6보다 큰 학생의 정보를 구하시오
-- SELECT *
-- FROM  Student
-- WHERE GPA &gt; 3.6;

-- 3. CS에 합격한 학생의 아이디를 구하시오
-- SELECT distinct sID
-- FROM Apply
-- WHERE major='CS' and decision='Y'   -- 'CS'와 'cs'는 다르다. 대소문자 구분함!

-- 3.1 만약 CS에 합격한 경우는 몇 개인가? 하면 distinct를 사용하지 않아야 함.

-- 4. Cartesian Product
-- SELECT *
-- FROM Student, Apply

-- 5. Cartesian Product + 조인조건
-- SELECT *
-- FROM Student, Apply
-- where Student.sID = Apply.sID

-- SELECT Student.sID, cName, major, decision
-- FROM Student, Apply
-- where Student.sID = Apply.sID

-- 6. 지원한 학생의 아이디, 이름, GPA, 지원대학이름, 대학등록생수를 구하시오
-- SELECT Student.sID, Student.sName, Student.GPA, College.cName, College.enrollment
-- FROM Student, Apply, College
-- WHERE (Student.sID = Apply.sID) and (Apply.cName = College.cName) 
-- Apply.cName과 College.cName 두 개의 attribute가 결과 table에 나타나는데, select에서 College.cName만 뽑아내서 하나만 출력됨.

-- 7. bio관련 학과(이름에 bio라는 글자가 들어가는 학과)에 지원한 학생의 아이디와 전공을 구하시오
-- SELECT Apply.sID, Apply.major
-- FROM Apply
-- WHERE Apply.major like '%bio%'











</sql><sql name="SQL 7">-- 10주차 목요일 수업시간 1

-- 학생의 아이디, 이름, GPA, sizeHS를 구하시오
-- SELECT sID, sName, GPA, sizeHS
-- FROM Student

-- 1. 고등학교의 학생수가 많으면 GPA를 올려주고, 학생수가 적으면 GPA를 내려줌
-- scaledGPA = GPA * (sizeHS / 1000.0)
-- SELECT sID, sName, GPA, sizeHS,  GPA * (sizeHS / 1000.0) as scaledGPA
-- FROM Student
	-- 1000.0 으로 integer가 아닌 float형으로 나눠줘야 함. integer로 하면 0으로 되는 값들이 생김

-- 2. 학생의 아이디, 이름, GPA, 지원대학, 대학등록생(enrollment)을 구하시오
-- 2 - 1)
-- SELECT Student.sID, Student.sName, Student.GPA, College.cName, College.enrollment
-- FROM Student, Apply, College
-- WHERE (Student.sID = Apply.sID) and (Apply.cName = College.cName) 
-- 2 - 2) alias
-- SELECT S.sID, S.sName, S.GPA, C.cName, C.enrollment
-- FROM Student S, Apply A, College C
-- WHERE (S.sID = A.sID) and (A.cName = C.cName) 

-- 3. GPA가 같은 학생의 쌍을 구하시오 (학생1의 아이디, 이름, GPA, 학생2의 아이디, 이름, GPA)
	-- '&lt;&gt;' 은 '!='과 똑같음
-- 3-1)	
-- SELECT S1.sID, S1.sName, S1.GPA, S2.sID, S2.sName, S2.GPA
-- FROM Student S1, Student S2
-- WHERE (S1.GPA = S2.GPA) and (S1.sID &lt; S2.sID)
-- 3-2)
SELECT S1.sID, S1.sName, S1.GPA, S2.sID, S2.sName, S2.GPA
FROM Student S1, Student S2
WHERE (S1.GPA = S2.GPA) and (S1.sID &lt; S2.sID)
order by S1.sID DESC








</sql><sql name="SQL 8">-- 10주차 목요일 수업시간 2

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 1. 학생이름과 학교이름을 모두 구하시오.
-- SELECT sName  as name FROM Student
-- UNION
-- SELECT cName as name FROM College 
-- ORDER by sName;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2. Student table에는 동명이인 (Amy, Craig)이 있었는데 UNION(합집합)을 사용했더니 중복이 사라짐.
-- 그런데 만약 학생, 학교가 몇 명 있는지 count하기 위한 의도였다면, 중복이 사라지면 안됌. -&gt; ALL
-- SELECT sName  as name FROM Student
-- UNION ALL
-- SELECT cName as name FROM College 
-- ORDER by sName;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 3. CS와 EE에 모두 지원한 학생의 아이디를 구하시오. (INTERSECT)
-- SELECT sID
-- FROM Apply
-- WHERE major='CS'
-- INTERSECT
-- SELECT sID
-- FROM Apply
-- WHERE major='EE'

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 4. CS와 EE에 모두 지원한 학생의 아이디를 구하시오. (join 사용해라)
-- 한 사람을 적는 것이기 때문에 A1.sID = A2.sID가 필요함
-- SELECT DISTINCT A1.sID
-- FROM Apply A1, Apply A2
-- WHERE (A1.sID = A2.sID) AND (A1.major='CS' AND  A2.major='EE')

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 5. CS에 지원하고, EE에는 지원하지 않은 학생을 구하라 (EXCEPT 사용)
SELECT sID
FROM Apply
WHERE major = 'CS'
EXCEPT
SELECT sID
FROM Apply
WHERE major = 'EE'

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 6. CS에 지원하고, EE에는 지원하지 않은 학생을 구하라 (join 연산자로 바꿀 수 있을까?)
-- 모든 집합 연산자를 join 연산자로 바꿀 수 있는 것은 아니다! (더 공부 해봐야 할듯)







</sql><sql name="SQL 9">--  11주차 온라인 강의 (1) 실습 없었음. 
-- 11주차 오프라인 강의 

-- 1. CS에 지원한 학생의 아이디, 이름을 구하시오 (IN 연산자 사용 X)
-- SELECT DISTINCT S.sID, S.sName
-- FROM Student as S, Apply as A
-- WHERE S.sID = A.sID and major='CS'

-- 2. CS에 지원한 학생의 아이디, 이름을 구하시오 (IN 연산자 사용 O)
-- SELECT  S.sID, s.sName  
-- FROM Student as S
-- WHERE S.sID in
-- 	(SELECT A.sID
-- 	FROM Apply as A
-- 	WHERE A.major='CS');
-- 학생 한명, 한명에 대해서 test하기 때문에 중복되어 나올 일이 없어서 DISTINCT를 사용하지 않아도 된다.
	


-- 3-1) CS에 지원한 학생의 GPA를 구하시오. (IN 연산자 사용 X)
-- SELECT DISTINCT s.sID,  S.GPA
-- FROM Student as S, Apply as A
-- WHERE S.sID = A.sID and major='CS'

-- SELECT DISTINCT  S.GPA
-- FROM Student as S, Apply as A
-- WHERE S.sID = A.sID and major='CS'
	
-- 3-2) CS에 지원한 학생의 GPA를 구하시오. (IN 연산자 사용 O)	
-- SELECT  s.sID, s.GPA  
-- FROM Student as S
-- WHERE S.sID in
-- 	(SELECT A.sID
-- 	FROM Apply as A
-- 	WHERE A.major='CS');
	
-- 4. CS에 지원하고, EE에는 지원하지 않은 학생의 아이디와 이름을 구하시오 
-- 4-1) 차집합 사용
-- SELECT S.sID, S.sName
-- FROM Student as S, Apply as A
-- WHERE S.sID=A.sID and A.major='CS'
-- EXCEPT
-- SELECT S.sID, S.sName
-- FROM Student as S, Apply as A
-- WHERE S.sID=A.sID and A.major='EE'

-- 4-2) IN 사용
-- SELECT S.sID, S.sName
-- FROM Student as S
-- WHERE 
-- 	sID IN(SELECT A.sID
-- 	FROM Apply as A
-- 	WHERE A.major='CS')
-- 	AND
-- 	sID NOT IN (SELECT A.sID
-- 	FROM Apply as A
-- 	WHERE A.major='EE')


-- 5. EIXSTS(공집합? = 조건에 맞는게 하나도 없는가?), NOT EXISTS(공집합이 아닌가? = 조건에 맞는게 하나라도 존재하는가?)
-- 같은 주(state)에 다른 대학이 있는 대학의 이름과 주(state)
-- SELECT C1. cName, C1.state
-- FROM College as C1
-- WHERE EXISTS 
-- 	(SELECT *
-- 	FROM College as C2
-- 	WHERE C1.state = C2.state AND C1.cName != C2.cName)

-- EXISTS -&gt; NOT EXISTS
-- SELECT C1. cName, C1.state
-- FROM College as C1
-- WHERE NOT EXISTS 
-- 	(SELECT *
-- 	FROM College as C2
-- 	WHERE C1.state = C2.state AND C1.cName != C2.cName)


-- 6. 재학생수(enrollment)가 가장 많은 대학의 이름을 구하시오. hint : use EXISTS / NOT EXISTS
-- = 자신보다 재학생수가 많은 대학이 없는 대학의 이름
-- SELECT C1.cName
-- FROM College as C1
-- WHERE NOT EXISTS 
-- 	(SELECT *
-- 	FROM College as C2
-- 	WHERE C1.enrollment &lt; C2.enrollment) -- 나보다 enrollment가 많은 대학이 없는 = 나의 enrollment가 가장 큼

-- 7. GPA가 가장 높은 학생의 이름과 GPA를 구하시오
-- SELECT S1.sID, S1.sName, S1.GPA
-- FROM Student as S1
-- WHERE NOT EXISTS 
-- 	(SELECT *
-- 	FROM Student as S2
-- 	WHERE S1.GPA &lt; S2.GPA) -- 나보다 enrollment가 많은 대학이 없는 = 나의 enrollment가 가장 큼


-- 8. ALL, ANY로 구현할 수 있는데 SQLite에서는 구현되지는 않는다.
-- 모든 GPA를 구하고, 그 GPA들보다 크거나 같은 GPA를 구하라
-- SELECT sName, GPA
-- FROM Student
-- WHERE GPA &gt;= ALL (SELECT GPA from Student)


-- 9. 모든 학생의 GPA의 평균을 구하시오
-- SELECT AVG(S.GPA)
-- FROM Student as S

-- 10. CS에 지원한 학생 중 최소 GPA를 구하시오.
SELECT min(S.GPA)
FROM Student as S, Apply as A
WHERE S.sID=A.sID AND A.major='CS'</sql><current_tab id="3"/></tab_sql></sqlb_project>
